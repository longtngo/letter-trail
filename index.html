<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Letter Trail Game</title>
    <style>
      :root {
        --bg: #f4efe6;
        --card: #ffffff;
        --ink: #1f2933;
        --muted: #6a7685;
        --accent: #14532d;
        --accent-soft: #d1fae5;
        --danger: #991b1b;
        --danger-soft: #fee2e2;
        --tile: #f8e9bf;
        --tile-border: #b0893c;
        --tile-text: #5b3a00;
      }

      * {
        box-sizing: border-box;
      }

      [hidden] {
        display: none !important;
      }

      body {
        margin: 0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at top, #fffdf8 0%, var(--bg) 65%);
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 20px;
      }

      .app {
        width: min(940px, 100%);
        background: var(--card);
        border: 1px solid #e6e2d9;
        border-radius: 18px;
        box-shadow: 0 16px 36px rgba(31, 41, 51, 0.12);
        padding: 24px;
      }

      .loader-screen {
        width: min(480px, 100%);
        background: var(--card);
        border: 1px solid #e6e2d9;
        border-radius: 18px;
        box-shadow: 0 16px 36px rgba(31, 41, 51, 0.12);
        padding: 28px;
        display: grid;
        justify-items: center;
        gap: 14px;
        text-align: center;
      }

      .spinner {
        width: 44px;
        height: 44px;
        border-radius: 999px;
        border: 4px solid #d6e0ea;
        border-top-color: #243b53;
        animation: spin 0.9s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .loader-title {
        margin: 0;
        font-size: 1.25rem;
      }

      .loader-message {
        margin: 0;
        color: var(--muted);
      }

      h1 {
        margin: 0;
        font-size: 1.8rem;
      }

      .subtitle {
        margin: 8px 0 20px;
        color: var(--muted);
      }

      .subtitle select {
        min-width: 0;
        width: auto;
        margin: 0 6px;
        padding: 6px 8px;
        font-size: 0.95rem;
        vertical-align: baseline;
      }

      select {
        min-width: 180px;
        font-size: 0.95rem;
        padding: 9px 10px;
        border-radius: 10px;
        border: 1px solid #c8d1dc;
        background: #fff;
        color: var(--ink);
      }

      .tiles {
        display: flex;
        gap: 12px;
        margin-bottom: 18px;
      }

      .tile {
        width: 68px;
        height: 68px;
        border-radius: 10px;
        border: 1px solid var(--tile-border);
        background: linear-gradient(180deg, #fff8dd 0%, var(--tile) 100%);
        color: var(--tile-text);
        font-size: 2rem;
        font-weight: 800;
        display: grid;
        place-items: center;
        text-transform: uppercase;
        box-shadow: 0 6px 14px rgba(91, 58, 0, 0.2);
      }

      .input-row {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }

      input[type="text"] {
        flex: 1;
        min-width: 240px;
        font-size: 1rem;
        padding: 12px;
        border-radius: 10px;
        border: 1px solid #c8d1dc;
        outline: none;
      }

      input[type="text"]:focus {
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
      }

      button {
        border: none;
        border-radius: 10px;
        padding: 10px 14px;
        font-size: 0.95rem;
        font-weight: 600;
        background: #243b53;
        color: white;
        cursor: pointer;
      }

      button:hover {
        filter: brightness(1.08);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .actions {
        display: flex;
        gap: 10px;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }

      .scoreboard {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 12px;
      }

      .pill {
        background: #f2f6fa;
        border: 1px solid #d6e0ea;
        border-radius: 999px;
        padding: 8px 12px;
        font-weight: 600;
      }

      .status {
        min-height: 24px;
        margin-bottom: 12px;
        padding: 8px 10px;
        border-radius: 8px;
        background: #f4f5f7;
        color: #2d3748;
      }

      .status.success {
        background: var(--accent-soft);
        color: var(--accent);
      }

      .status.error {
        background: var(--danger-soft);
        color: var(--danger);
      }

      .columns {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 16px;
      }

      .panel {
        border: 1px solid #dbe3ed;
        border-radius: 12px;
        padding: 12px;
        background: #fafcff;
      }

      .panel h2 {
        margin: 0 0 8px;
        font-size: 1rem;
      }

      ul {
        margin: 0;
        padding-left: 18px;
      }

      li {
        margin: 5px 0;
      }

      .solutions {
        max-height: 280px;
        overflow: auto;
      }

      .solution-word {
        font-weight: 700;
      }

      .solution-meaning {
        color: var(--muted);
      }

      @media (max-width: 760px) {
        .columns {
          grid-template-columns: 1fr;
        }

        .tile {
          width: 60px;
          height: 60px;
          font-size: 1.7rem;
        }

        select {
          min-width: 140px;
        }

        .subtitle select {
          margin: 4px 4px;
        }
      }
    </style>
  </head>
  <body>
    <section id="loader" class="loader-screen" aria-live="polite">
      <div class="spinner" aria-hidden="true"></div>
      <h2 class="loader-title">Preparing game...</h2>
      <p id="loaderMessage" class="loader-message">Loading game data...</p>
    </section>

    <main id="app" class="app" hidden>
      <h1>Letter Trail</h1>
      <p id="ruleText" class="subtitle">
        Enter
        <select id="themeSelect" aria-label="Theme">
          <option value="dictionary" selected>an English word</option>
          <option value="pokemon">a Pokemon name</option>
          <option value="countries">a country name</option>
          <option value="capitals">a capital city name</option>
        </select>
        that contains all
        <select id="letterCountSelect" aria-label="Number of letters">
          <option value="2">2</option>
          <option value="3" selected>3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
        </select>
        letters in this exact order.
      </p>

      <div id="tiles" class="tiles"></div>

      <div class="input-row">
        <input
          id="wordInput"
          type="text"
          placeholder="Type your guess and press Enter"
          autocomplete="off"
        />
        <button id="submitBtn" type="button">Submit</button>
      </div>

      <div class="actions">
        <button id="showSolutionsBtn" type="button">Show All Solutions (0)</button>
        <button id="newGameBtn" type="button">New Game</button>
      </div>

      <div id="status" class="status">Loading game...</div>

      <section class="scoreboard">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill">Accepted: <span id="acceptedCount">0</span></div>
        <div class="pill">Wrong: <span id="wrongCount">0</span></div>
      </section>

      <section class="columns">
        <article class="panel">
          <h2>Accepted Words</h2>
          <ul id="acceptedList">
            <li>No accepted words yet.</li>
          </ul>
        </article>

        <article class="panel">
          <h2>Wrong Words</h2>
          <ul id="wrongList">
            <li>No wrong words yet.</li>
          </ul>
        </article>
      </section>

      <section class="panel" style="margin-top: 16px">
        <h2>All Solutions + Meaning</h2>
        <div id="solutionsBox" class="solutions">Click "Show All Solutions".</div>
      </section>
    </main>

    <script>
      const appEl = document.getElementById("app");
      const loaderEl = document.getElementById("loader");
      const loaderMessageEl = document.getElementById("loaderMessage");
      const themeSelect = document.getElementById("themeSelect");
      const letterCountSelect = document.getElementById("letterCountSelect");
      const wordInput = document.getElementById("wordInput");
      const tilesEl = document.getElementById("tiles");
      const statusEl = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const acceptedCountEl = document.getElementById("acceptedCount");
      const wrongCountEl = document.getElementById("wrongCount");
      const acceptedListEl = document.getElementById("acceptedList");
      const wrongListEl = document.getElementById("wrongList");
      const solutionsBoxEl = document.getElementById("solutionsBox");
      const submitBtn = document.getElementById("submitBtn");
      const newGameBtn = document.getElementById("newGameBtn");
      const showSolutionsBtn = document.getElementById("showSolutionsBtn");

      const LETTERS = "abcdefghijklmnopqrstuvwxyz";
      const MIN_SOLUTIONS = 1;
      const CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000;
      const CACHE_PREFIX = "letterTrailCache:v1:";
      const CACHE_MAX_ENTRIES = 300;
      const DICTIONARY_SOURCE_URL =
        "https://raw.githubusercontent.com/dolph/dictionary/master/enable1.txt";
      const DICTIONARY_TARGET_SIZE = 65000;

      const THEMES = {
        dictionary: {
          label: "English Dictionary",
          prompt: "an English word",
        },
        pokemon: {
          label: "Pokemon Names",
          prompt: "a Pokemon name",
        },
        countries: {
          label: "Country Names",
          prompt: "a country name",
        },
        capitals: {
          label: "Capital Cities",
          prompt: "a capital city name",
        },
      };

      const SCRABBLE_POINTS = {
        a: 1,
        b: 3,
        c: 3,
        d: 2,
        e: 1,
        f: 4,
        g: 2,
        h: 4,
        i: 1,
        j: 8,
        k: 5,
        l: 1,
        m: 3,
        n: 1,
        o: 1,
        p: 3,
        q: 10,
        r: 1,
        s: 1,
        t: 1,
        u: 1,
        v: 4,
        w: 4,
        x: 8,
        y: 4,
        z: 10,
      };

      let targetLetters = [];
      let solutions = [];
      let solutionSet = new Set();
      let acceptedGuesses = [];
      let wrongGuesses = [];
      let totalScore = 0;
      let isBusy = false;

      let currentThemeId = themeSelect.value;
      let letterCount = Number(letterCountSelect.value);
      let activeWords = [];
      let activeWordSet = new Set();
      let activeMetaByWord = {};
      let meaningCache = {};
      const themeEntriesMemory = {};

      function showLoader(message) {
        loaderEl.hidden = false;
        appEl.hidden = true;
        loaderMessageEl.textContent = message;
      }

      function hideLoader() {
        loaderEl.hidden = true;
        appEl.hidden = false;
      }

      function getCacheStorageKey(cacheKey) {
        return `${CACHE_PREFIX}${cacheKey}`;
      }

      function readCache(cacheKey) {
        try {
          const raw = localStorage.getItem(getCacheStorageKey(cacheKey));
          if (!raw) {
            return null;
          }

          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== "object") {
            localStorage.removeItem(getCacheStorageKey(cacheKey));
            return null;
          }

          if (typeof parsed.expiresAt !== "number" || Date.now() > parsed.expiresAt) {
            localStorage.removeItem(getCacheStorageKey(cacheKey));
            return null;
          }

          return parsed.data ?? null;
        } catch {
          return null;
        }
      }

      function pruneCache() {
        try {
          const now = Date.now();
          const cacheEntries = [];

          for (let index = 0; index < localStorage.length; index += 1) {
            const key = localStorage.key(index);
            if (!key || !key.startsWith(CACHE_PREFIX)) {
              continue;
            }

            const raw = localStorage.getItem(key);
            if (!raw) {
              continue;
            }

            try {
              const parsed = JSON.parse(raw);
              if (!parsed || typeof parsed !== "object") {
                localStorage.removeItem(key);
                continue;
              }

              if (typeof parsed.expiresAt !== "number" || parsed.expiresAt <= now) {
                localStorage.removeItem(key);
                continue;
              }

              cacheEntries.push({
                key,
                cachedAt:
                  typeof parsed.cachedAt === "number" ? parsed.cachedAt : parsed.expiresAt,
              });
            } catch {
              localStorage.removeItem(key);
            }
          }

          if (cacheEntries.length <= CACHE_MAX_ENTRIES) {
            return;
          }

          cacheEntries.sort((a, b) => a.cachedAt - b.cachedAt);
          const removeCount = cacheEntries.length - CACHE_MAX_ENTRIES;
          for (let i = 0; i < removeCount; i += 1) {
            localStorage.removeItem(cacheEntries[i].key);
          }
        } catch {
          // localStorage unavailable or blocked; skip pruning
        }
      }

      function writeCache(cacheKey, data) {
        try {
          localStorage.setItem(
            getCacheStorageKey(cacheKey),
            JSON.stringify({
              cachedAt: Date.now(),
              expiresAt: Date.now() + CACHE_TTL_MS,
              data,
            })
          );
          pruneCache();
        } catch {
          // localStorage quota/unavailable; continue without persistence
        }
      }

      async function fetchJsonWithCache(cacheKey, url) {
        const cachedData = readCache(cacheKey);
        if (cachedData !== null) {
          return cachedData;
        }

        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Request failed (${response.status})`);
        }

        const data = await response.json();
        writeCache(cacheKey, data);
        return data;
      }

      function normalizeForMatch(value) {
        return (value || "")
          .trim()
          .toLowerCase()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .replace(/[^a-z]/g, "");
      }

      function isAlphaWord(word) {
        return /^[a-z]+$/.test(word);
      }

      function containsInOrder(word, letters) {
        let fromIndex = 0;
        for (const letter of letters) {
          const index = word.indexOf(letter, fromIndex);
          if (index === -1) {
            return false;
          }
          fromIndex = index + 1;
        }
        return true;
      }

      function titleCaseFromDashText(value) {
        return (value || "")
          .split("-")
          .filter(Boolean)
          .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
          .join(" ");
      }

      function setStatus(message, type = "neutral") {
        statusEl.textContent = message;
        statusEl.className = "status";
        if (type === "success") {
          statusEl.classList.add("success");
        }
        if (type === "error") {
          statusEl.classList.add("error");
        }
      }

      function setBusyState(value) {
        isBusy = value;
        showSolutionsBtn.disabled = value;
        newGameBtn.disabled = value;
        submitBtn.disabled = value;
        themeSelect.disabled = value;
        letterCountSelect.disabled = value;
        wordInput.disabled = value;
      }

      function updateRuleText() {
        wordInput.placeholder =
          currentThemeId === "dictionary"
            ? "Type your guess and press Enter"
            : "Type a name and press Enter";
      }

      function updateSolutionsButtonLabel() {
        showSolutionsBtn.textContent = `Show All Solutions (${solutions.length})`;
      }

      function renderTiles() {
        tilesEl.innerHTML = "";
        targetLetters.forEach((letter) => {
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.textContent = letter;
          tilesEl.appendChild(tile);
        });
      }

      function renderScoreboard() {
        scoreEl.textContent = totalScore;
        acceptedCountEl.textContent = acceptedGuesses.length;
        wrongCountEl.textContent = wrongGuesses.length;
      }

      function renderAcceptedWords() {
        acceptedListEl.innerHTML = "";
        if (!acceptedGuesses.length) {
          acceptedListEl.innerHTML = "<li>No accepted words yet.</li>";
          return;
        }

        acceptedGuesses.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = `${item.displayWord} (+${item.points}) - ${item.meaning}`;
          acceptedListEl.appendChild(li);
        });
      }

      function renderWrongWords() {
        wrongListEl.innerHTML = "";
        if (!wrongGuesses.length) {
          wrongListEl.innerHTML = "<li>No wrong words yet.</li>";
          return;
        }

        wrongGuesses.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = `${item.word} (${item.reason})`;
          wrongListEl.appendChild(li);
        });
      }

      function updateAllLists() {
        renderScoreboard();
        renderAcceptedWords();
        renderWrongWords();
      }

      function calculateWordScore(word) {
        let sum = 0;
        for (const char of word) {
          sum += SCRABBLE_POINTS[char] || 0;
        }
        return sum + word.length;
      }

      function parseDictionaryText(rawText) {
        const unique = new Set();
        const rows = rawText.split(/\r?\n/);

        rows.forEach((line) => {
          const word = normalizeForMatch(line);
          if (word.length < 2 || !isAlphaWord(word)) {
            return;
          }
          unique.add(word);
        });

        return Array.from(unique).sort((a, b) => a.localeCompare(b));
      }

      function downsampleWords(words, limit) {
        if (words.length <= limit) {
          return words;
        }

        const step = words.length / limit;
        const selected = [];
        const selectedSet = new Set();

        for (let i = 0; i < limit; i += 1) {
          const index = Math.min(words.length - 1, Math.floor(i * step));
          const candidate = words[index];
          if (!selectedSet.has(candidate)) {
            selected.push(candidate);
            selectedSet.add(candidate);
          }
        }

        if (selected.length < limit) {
          for (const word of words) {
            if (selectedSet.has(word)) {
              continue;
            }
            selected.push(word);
            selectedSet.add(word);
            if (selected.length >= limit) {
              break;
            }
          }
        }

        return selected;
      }

      function dedupeEntries(entries) {
        const byWord = {};

        entries.forEach((entry) => {
          if (!entry || !entry.word) {
            return;
          }
          const word = entry.word;
          if (!byWord[word]) {
            byWord[word] = {
              word,
              display: entry.display || word,
              meaning: entry.meaning || "",
            };
            return;
          }

          if (!byWord[word].meaning && entry.meaning) {
            byWord[word].meaning = entry.meaning;
          }
        });

        return Object.values(byWord).sort((a, b) => a.word.localeCompare(b.word));
      }

      async function loadDictionaryEntries() {
        const cachedWords = readCache("theme:dictionary:words");
        if (Array.isArray(cachedWords) && cachedWords.length) {
          return cachedWords.map((word) => ({ word, display: word, meaning: "" }));
        }

        const response = await fetch(DICTIONARY_SOURCE_URL);
        if (!response.ok) {
          throw new Error("Dictionary download failed.");
        }

        const rawText = await response.text();
        const parsedWords = parseDictionaryText(rawText);
        const selectedWords = downsampleWords(parsedWords, DICTIONARY_TARGET_SIZE);
        writeCache("theme:dictionary:words", selectedWords);
        return selectedWords.map((word) => ({ word, display: word, meaning: "" }));
      }

      async function loadPokemonEntries() {
        const cachedEntries = readCache("theme:pokemon:entries");
        if (Array.isArray(cachedEntries) && cachedEntries.length) {
          return cachedEntries;
        }

        const data = await fetchJsonWithCache(
          "theme:pokemon:raw",
          "https://pokeapi.co/api/v2/pokemon?limit=2000"
        );

        const entries = dedupeEntries(
          (data.results || [])
            .map((item) => {
              const display = titleCaseFromDashText(item.name || "");
              const word = normalizeForMatch(item.name || "");
              if (word.length < 2) {
                return null;
              }
              return {
                word,
                display,
                meaning: "Pokemon name.",
              };
            })
            .filter(Boolean)
        );

        writeCache("theme:pokemon:entries", entries);
        return entries;
      }

      async function loadGeoEntries(kind) {
        const cacheKey =
          kind === "countries" ? "theme:countries:entries" : "theme:capitals:entries";
        const cachedEntries = readCache(cacheKey);
        if (Array.isArray(cachedEntries) && cachedEntries.length) {
          return cachedEntries;
        }

        const countriesData = await fetchJsonWithCache(
          "theme:geo:raw",
          "https://restcountries.com/v3.1/all?fields=name,capital"
        );

        const countryEntries = [];
        const capitalEntries = [];

        countriesData.forEach((item) => {
          const countryName = (item?.name?.common || "").trim();
          const countryWord = normalizeForMatch(countryName);
          if (countryWord.length >= 2) {
            countryEntries.push({
              word: countryWord,
              display: countryName,
              meaning: "Country name.",
            });
          }

          const capitals = Array.isArray(item?.capital) ? item.capital : [];
          capitals.forEach((capital) => {
            const display = (capital || "").trim();
            const word = normalizeForMatch(display);
            if (word.length < 2) {
              return;
            }
            capitalEntries.push({
              word,
              display,
              meaning: countryName ? `Capital city of ${countryName}.` : "Capital city.",
            });
          });
        });

        const uniqueCountries = dedupeEntries(countryEntries);
        const uniqueCapitals = dedupeEntries(capitalEntries);
        writeCache("theme:countries:entries", uniqueCountries);
        writeCache("theme:capitals:entries", uniqueCapitals);

        return kind === "countries" ? uniqueCountries : uniqueCapitals;
      }

      async function loadEntriesForTheme(themeId) {
        if (themeEntriesMemory[themeId]) {
          return themeEntriesMemory[themeId];
        }

        let entries = [];
        if (themeId === "dictionary") {
          entries = await loadDictionaryEntries();
        } else if (themeId === "pokemon") {
          entries = await loadPokemonEntries();
        } else if (themeId === "countries") {
          entries = await loadGeoEntries("countries");
        } else if (themeId === "capitals") {
          entries = await loadGeoEntries("capitals");
        }

        themeEntriesMemory[themeId] = entries;
        return entries;
      }

      function setActiveEntries(entries) {
        activeWords = [];
        activeMetaByWord = {};

        entries.forEach((entry) => {
          if (!entry || !entry.word || entry.word.length < 2) {
            return;
          }
          activeWords.push(entry.word);
          activeMetaByWord[entry.word] = {
            display: entry.display || entry.word,
            meaning: entry.meaning || "",
          };
        });

        activeWords.sort((a, b) => a.localeCompare(b));
        activeWordSet = new Set(activeWords);
      }

      function getDisplayWord(word) {
        return activeMetaByWord[word]?.display || word;
      }

      function getMeaningCacheKey(word) {
        return `${currentThemeId}:${word}`;
      }

      async function getMeaning(word) {
        const cacheKey = getMeaningCacheKey(word);
        if (meaningCache[cacheKey]) {
          return meaningCache[cacheKey];
        }

        const localMeaning = activeMetaByWord[word]?.meaning;
        if (localMeaning) {
          meaningCache[cacheKey] = localMeaning;
          return localMeaning;
        }

        if (currentThemeId !== "dictionary") {
          meaningCache[cacheKey] = "Meaning unavailable.";
          return meaningCache[cacheKey];
        }

        let meaning = "";
        try {
          const data = await fetchJsonWithCache(
            `dictionaryapi:meaning:${word}`,
            `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(
              word
            )}`
          );
          meaning = data?.[0]?.meanings?.[0]?.definitions?.[0]?.definition || "";
        } catch {
          meaning = "";
        }

        meaningCache[cacheKey] = meaning || "Meaning unavailable.";
        return meaningCache[cacheKey];
      }

      function fetchSolutionsForLetters(letters) {
        const found = [];
        for (const word of activeWords) {
          if (containsInOrder(word, letters)) {
            found.push(word);
          }
        }
        return found;
      }

      function chooseLettersFromWord(word, count) {
        if (count >= word.length) {
          return word.split("").slice(0, count);
        }

        const positions = new Set();
        while (positions.size < count) {
          positions.add(Math.floor(Math.random() * word.length));
        }

        return Array.from(positions)
          .sort((a, b) => a - b)
          .map((index) => word[index]);
      }

      function getMaxSolutionsTarget() {
        if (currentThemeId === "dictionary") {
          if (letterCount === 2) {
            return 900;
          }
          if (letterCount === 3) {
            return 500;
          }
          return 350;
        }
        return 300;
      }

      function isThemeWord(word) {
        return activeWordSet.has(word);
      }

      function rejectGuess(inputWord, dedupeKey, reason) {
        if (!wrongGuesses.some((item) => item.key === dedupeKey)) {
          wrongGuesses.push({ key: dedupeKey, word: inputWord, reason });
        }
        renderWrongWords();
        renderScoreboard();
        setStatus(`Rejected "${inputWord}": ${reason}`, "error");
        wordInput.focus();
        wordInput.select();
      }

      async function generateRound() {
        setBusyState(true);
        setStatus("Generating letters and finding solutions...");

        const eligibleWords = activeWords.filter((word) => word.length >= letterCount);
        if (!eligibleWords.length) {
          setBusyState(false);
          setStatus(
            "No words available for this letter count. Try a smaller letter count.",
            "error"
          );
          return;
        }

        const MAX_ATTEMPTS = 420;
        const maxSolutionsTarget = getMaxSolutionsTarget();
        let fallback = null;

        for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt += 1) {
          const seedWord = eligibleWords[Math.floor(Math.random() * eligibleWords.length)];
          const letters = chooseLettersFromWord(seedWord, letterCount);
          const roundSolutions = fetchSolutionsForLetters(letters);

          if (roundSolutions.length < MIN_SOLUTIONS) {
            continue;
          }

          if (!fallback || roundSolutions.length < fallback.solutions.length) {
            fallback = { letters, solutions: roundSolutions };
          }

          if (roundSolutions.length <= maxSolutionsTarget) {
            targetLetters = letters;
            solutions = roundSolutions;
            solutionSet = new Set(roundSolutions);
            updateSolutionsButtonLabel();
            renderTiles();
            setBusyState(false);
            setStatus(
              `New game ready. Letters: ${letters
                .join(" ")
                .toUpperCase()} (${roundSolutions.length} solutions found).`
            );
            wordInput.focus();
            return;
          }
        }

        if (fallback) {
          targetLetters = fallback.letters;
          solutions = fallback.solutions;
          solutionSet = new Set(fallback.solutions);
          updateSolutionsButtonLabel();
          renderTiles();
          setBusyState(false);
          setStatus(
            `New game ready. Letters: ${fallback.letters
              .join(" ")
              .toUpperCase()} (${fallback.solutions.length} solutions found).`
          );
          wordInput.focus();
          return;
        }

        setBusyState(false);
        setStatus("Could not generate a round right now. Try New Game.", "error");
      }

      async function startNewGame() {
        currentThemeId = themeSelect.value;
        letterCount = Number(letterCountSelect.value);
        if (!Number.isInteger(letterCount) || letterCount < 2 || letterCount > 6) {
          letterCount = 3;
          letterCountSelect.value = "3";
        }

        targetLetters = [];
        solutions = [];
        solutionSet = new Set();
        acceptedGuesses = [];
        wrongGuesses = [];
        totalScore = 0;
        meaningCache = {};
        wordInput.value = "";

        updateRuleText();
        solutionsBoxEl.textContent = 'Click "Show All Solutions".';
        updateSolutionsButtonLabel();
        updateAllLists();
        renderTiles();
        setBusyState(true);
        setStatus(`Loading ${THEMES[currentThemeId].label}...`);

        try {
          const entries = await loadEntriesForTheme(currentThemeId);
          setActiveEntries(entries);
          await generateRound();
        } catch {
          setBusyState(false);
          setStatus(
            `Error loading ${THEMES[currentThemeId].label}. Please check your internet and try again.`,
            "error"
          );
        }
      }

      async function submitGuess() {
        if (isBusy || !targetLetters.length) {
          return;
        }

        const rawInput = wordInput.value.trim();
        const word = normalizeForMatch(rawInput);
        if (!word) {
          return;
        }

        if (!isAlphaWord(word)) {
          rejectGuess(rawInput, word || rawInput.toLowerCase(), "Use letters A-Z only.");
          return;
        }

        if (acceptedGuesses.some((item) => item.word === word)) {
          rejectGuess(rawInput || getDisplayWord(word), word, "You already submitted this word.");
          return;
        }

        if (!containsInOrder(word, targetLetters)) {
          rejectGuess(
            rawInput || getDisplayWord(word),
            word,
            `Word must include ${targetLetters.join("-")} in order.`
          );
          return;
        }

        if (!isThemeWord(word)) {
          rejectGuess(
            rawInput || getDisplayWord(word),
            word,
            `Not found in ${THEMES[currentThemeId].label}.`
          );
          return;
        }

        if (!solutionSet.has(word)) {
          solutionSet.add(word);
          solutions.push(word);
          solutions.sort((a, b) => a.localeCompare(b));
          updateSolutionsButtonLabel();
        }

        const points = calculateWordScore(word);
        const meaning = await getMeaning(word);
        const displayWord = getDisplayWord(word);

        acceptedGuesses.push({ word, displayWord, points, meaning });
        totalScore += points;

        setStatus(`Accepted "${displayWord}" (+${points} points).`, "success");
        wordInput.value = "";
        wordInput.focus();
        updateAllLists();
      }

      async function showAllSolutions() {
        if (!solutions.length) {
          setStatus("No solutions to show.", "error");
          return;
        }

        setStatus("Loading meanings for all solutions...");
        setBusyState(true);

        const workers = [];
        const queue = [...solutions];
        const concurrency = currentThemeId === "dictionary" ? 8 : 16;
        const workerCount = Math.min(concurrency, queue.length);

        for (let i = 0; i < workerCount; i += 1) {
          workers.push(
            (async () => {
              while (queue.length) {
                const word = queue.pop();
                await getMeaning(word);
              }
            })()
          );
        }

        await Promise.all(workers);

        solutionsBoxEl.innerHTML = "";
        const list = document.createElement("ul");
        const fragment = document.createDocumentFragment();

        solutions.forEach((word) => {
          const li = document.createElement("li");

          const wordSpan = document.createElement("span");
          wordSpan.className = "solution-word";
          wordSpan.textContent = getDisplayWord(word);

          const meaningSpan = document.createElement("span");
          meaningSpan.className = "solution-meaning";
          meaningSpan.textContent = ` - ${
            meaningCache[getMeaningCacheKey(word)] || "Meaning unavailable."
          }`;

          li.appendChild(wordSpan);
          li.appendChild(meaningSpan);
          fragment.appendChild(li);
        });

        list.appendChild(fragment);
        solutionsBoxEl.appendChild(list);
        setBusyState(false);
        setStatus(`Displayed ${solutions.length} solution(s).`, "success");
      }

      wordInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          submitGuess();
        }
      });

      submitBtn.addEventListener("click", submitGuess);
      showSolutionsBtn.addEventListener("click", showAllSolutions);
      newGameBtn.addEventListener("click", startNewGame);
      themeSelect.addEventListener("change", startNewGame);
      letterCountSelect.addEventListener("change", startNewGame);

      async function initializeGame() {
        let initError = "";
        const initialThemeLabel = THEMES[themeSelect.value]?.label || "theme data";
        showLoader(`Loading ${initialThemeLabel}...`);

        try {
          await startNewGame();
        } catch {
          initError = "Error loading game data. Please refresh and try again.";
        } finally {
          hideLoader();
        }

        if (initError) {
          setStatus(initError, "error");
        }
      }

      initializeGame();
    </script>
  </body>
</html>
