<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Letter Trail - Focus Lane</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&family=Nunito:wght@400;600;800&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --paper: #f7f1da;
        --card: #fffdf4;
        --ink: #2b271f;
        --muted: #666152;
        --line: rgba(43, 39, 31, 0.18);
        --olive: #486a2e;
        --olive-soft: #e8f5dc;
        --tile: #f9e3a6;
        --danger: #7f2622;
        --danger-soft: #fbe6e4;
      }

      * {
        box-sizing: border-box;
      }

      [hidden] {
        display: none !important;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background:
          repeating-linear-gradient(
            0deg,
            rgba(96, 86, 58, 0.045) 0,
            rgba(96, 86, 58, 0.045) 2px,
            transparent 2px,
            transparent 34px
          ),
          var(--paper);
        color: var(--ink);
        font-family: "Nunito", sans-serif;
        padding: 24px;
      }

      .loader-screen {
        max-width: 430px;
        margin: 8vh auto 0;
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 16px;
        box-shadow: 0 16px 28px rgba(58, 49, 30, 0.12);
        padding: 24px;
        display: grid;
        justify-items: center;
        gap: 12px;
        text-align: center;
      }

      .spinner {
        width: 44px;
        height: 44px;
        border-radius: 999px;
        border: 4px solid rgba(72, 106, 46, 0.22);
        border-top-color: var(--olive);
        animation: spin 0.9s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .loader-title {
        margin: 0;
        font-family: "Kalam", cursive;
        font-size: 1.8rem;
      }

      .loader-message {
        margin: 0;
        color: var(--muted);
      }

      .board {
        max-width: 1140px;
        margin: 0 auto;
        display: grid;
        grid-template-columns: 1fr 290px;
        gap: 14px;
      }

      .panel {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 16px;
        box-shadow: 0 16px 28px rgba(58, 49, 30, 0.12);
      }

      .play {
        padding: 18px;
        display: grid;
        gap: 12px;
      }

      h1 {
        margin: 0;
        font-family: "Kalam", cursive;
        font-size: clamp(2rem, 4vw, 2.8rem);
        line-height: 1;
      }

      .sub {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .rule {
        margin: 0;
        line-height: 1.45;
      }

      select,
      input,
      button {
        font: inherit;
      }

      select {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 4px 8px;
        background: #fff;
      }

      .lane {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 12px;
        align-items: center;
      }

      .tiles {
        display: flex;
        gap: 10px;
      }

      .tile {
        width: 70px;
        aspect-ratio: 1;
        display: grid;
        place-items: center;
        background: var(--tile);
        border: 1px solid #bf943a;
        border-radius: 9px;
        box-shadow: 3px 3px 0 #bf943a;
        font-family: "Kalam", cursive;
        font-size: 2rem;
        font-weight: 700;
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease,
          color 0.2s ease;
      }

      .tile.matched {
        background: linear-gradient(180deg, #c9f5b5 0%, #a7e190 100%);
        border-color: #5e9f50;
        box-shadow: 3px 3px 0 #5e9f50;
        color: #23471d;
      }

      .tip {
        border-left: 2px solid var(--olive);
        padding-left: 10px;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .entry {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 10px;
      }

      input {
        border: 1px solid var(--line);
        border-radius: 11px;
        background: #fff;
        padding: 13px;
      }

      input:focus,
      select:focus {
        outline: 2px solid rgba(72, 106, 46, 0.28);
        outline-offset: 1px;
      }

      button {
        border: 0;
        border-radius: 11px;
        cursor: pointer;
        font-weight: 800;
        padding: 11px 16px;
      }

      button:disabled,
      input:disabled,
      select:disabled {
        opacity: 0.58;
        cursor: not-allowed;
      }

      .primary {
        background: var(--olive);
        color: #fff;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .ghost {
        border: 1px solid var(--line);
        background: #fff;
        color: var(--ink);
      }

      .status {
        background: #f2f3ef;
        border: 1px solid var(--line);
        border-radius: 12px;
        color: #4f4a3f;
        font-weight: 700;
        padding: 9px 11px;
        min-height: 44px;
        display: grid;
        align-items: center;
      }

      .status.success {
        background: var(--olive-soft);
        border-color: rgba(72, 106, 46, 0.28);
        color: #2f5720;
      }

      .status.error {
        background: var(--danger-soft);
        border-color: rgba(127, 38, 34, 0.24);
        color: var(--danger);
      }

      .cards {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }

      .card {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: #fff;
        padding: 11px;
      }

      .card h2 {
        margin: 0 0 8px;
        font-size: 1.02rem;
        font-family: "Kalam", cursive;
      }

      .solutions-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 8px;
      }

      .solutions-head h2 {
        margin: 0;
      }

      .card ul,
      .card .solutions {
        margin: 0;
        padding-left: 18px;
      }

      .card li {
        margin: 4px 0;
      }

      .card.wide {
        grid-column: 1 / -1;
      }

      .solutions {
        max-height: 280px;
        overflow: auto;
      }

      .solution-word {
        font-weight: 700;
      }

      .solution-meaning {
        color: var(--muted);
      }

      .rail {
        padding: 14px;
        position: sticky;
        top: 20px;
        height: fit-content;
        display: grid;
        gap: 10px;
      }

      .stat {
        border: 1px dashed var(--line);
        border-radius: 10px;
        background: #fff;
        padding: 9px;
      }

      .stat b {
        display: block;
        font-size: 0.78rem;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .stat span {
        font-size: 1.5rem;
        font-weight: 800;
      }

      .check {
        border-top: 1px dashed var(--line);
        padding-top: 10px;
        font-size: 0.9rem;
        color: var(--muted);
        display: grid;
        gap: 6px;
      }

      @media (max-width: 920px) {
        body {
          padding: 14px;
        }

        .board {
          grid-template-columns: 1fr;
        }

        .rail {
          position: static;
          display: grid;
          grid-template-columns: repeat(3, minmax(0, 1fr));
        }

        .check {
          grid-column: 1 / -1;
        }
      }

      @media (max-width: 620px) {
        body {
          padding: 10px;
        }

        .lane {
          grid-template-columns: 1fr;
        }

        .entry {
          grid-template-columns: 1fr;
        }

        .cards {
          grid-template-columns: 1fr;
        }

        .rail {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <section id="loader" class="loader-screen" aria-live="polite">
      <div class="spinner" aria-hidden="true"></div>
      <h2 class="loader-title">Preparing game...</h2>
      <p id="loaderMessage" class="loader-message">Loading game data...</p>
    </section>

    <main id="app" class="board" hidden>
      <section class="panel play">
        <h1>Letter Trail</h1>
        <p class="sub">Focus lane layout with sticky score rail for faster play.</p>

        <p class="rule">
          Enter
          <select id="themeSelect" aria-label="Theme">
            <option value="countries" selected>a country name</option>
            <option value="pokemon">a Pokemon name</option>
            <option value="dictionary">an English word</option>
            <option value="capitals">a capital city name</option>
          </select>
          that contains all
          <select id="letterCountSelect" aria-label="Number of letters">
            <option value="2">2</option>
            <option value="3" selected>3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
          </select>
          letters in this exact order.
        </p>

        <div class="lane">
          <div id="tiles" class="tiles"></div>
          <div class="tip">Try long names first to maximize points.</div>
        </div>

        <div class="entry">
          <input
            id="wordInput"
            type="text"
            placeholder="Type a name and press Enter"
            autocomplete="off"
          />
          <button id="submitBtn" type="button" class="primary">Submit</button>
          <button id="newGameBtn" type="button" class="ghost">New Game</button>
        </div>

        <div id="status" class="status">Loading game...</div>

        <section class="cards">
          <article class="card">
            <h2>Accepted Words</h2>
            <ul id="acceptedList">
              <li>No accepted words yet.</li>
            </ul>
          </article>
          <article class="card">
            <h2>Wrong Words</h2>
            <ul id="wrongList">
              <li>No wrong words yet.</li>
            </ul>
          </article>
          <article class="card wide">
            <div class="solutions-head">
              <h2>All Solutions + Meaning</h2>
              <button id="showSolutionsBtn" type="button" class="primary">
                Show All Solutions (0)
              </button>
            </div>
            <div id="solutionsBox" class="solutions"></div>
          </article>
        </section>
      </section>

      <aside class="panel rail">
        <div class="stat">
          <b>Score</b>
          <span id="score">0</span>
        </div>
        <div class="stat">
          <b>Accepted</b>
          <span id="acceptedCount">0</span>
        </div>
        <div class="stat">
          <b>Wrong</b>
          <span id="wrongCount">0</span>
        </div>
        <div class="check">
          <div>1. Keep letter order.</div>
          <div>2. Avoid duplicate guesses.</div>
          <div>3. Use Show All to inspect misses.</div>
        </div>
      </aside>
    </main>
    <script>
      const appEl = document.getElementById("app");
      const loaderEl = document.getElementById("loader");
      const loaderMessageEl = document.getElementById("loaderMessage");
      const themeSelect = document.getElementById("themeSelect");
      const letterCountSelect = document.getElementById("letterCountSelect");
      const wordInput = document.getElementById("wordInput");
      const tilesEl = document.getElementById("tiles");
      const statusEl = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const acceptedCountEl = document.getElementById("acceptedCount");
      const wrongCountEl = document.getElementById("wrongCount");
      const acceptedListEl = document.getElementById("acceptedList");
      const wrongListEl = document.getElementById("wrongList");
      const solutionsBoxEl = document.getElementById("solutionsBox");
      const submitBtn = document.getElementById("submitBtn");
      const newGameBtn = document.getElementById("newGameBtn");
      const showSolutionsBtn = document.getElementById("showSolutionsBtn");

      const LETTERS = "abcdefghijklmnopqrstuvwxyz";
      const MIN_SOLUTIONS = 1;
      const CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000;
      const CACHE_PREFIX = "letterTrailCache:v1:";
      const CACHE_MAX_ENTRIES = 300;
      const DICTIONARY_SOURCE_URL =
        "https://raw.githubusercontent.com/dolph/dictionary/master/enable1.txt";
      const DICTIONARY_TARGET_SIZE = 65000;

      const THEMES = {
        dictionary: {
          label: "English Dictionary",
          prompt: "an English word",
        },
        pokemon: {
          label: "Pokemon Names",
          prompt: "a Pokemon name",
        },
        countries: {
          label: "Country Names",
          prompt: "a country name",
        },
        capitals: {
          label: "Capital Cities",
          prompt: "a capital city name",
        },
      };

      const SCRABBLE_POINTS = {
        a: 1,
        b: 3,
        c: 3,
        d: 2,
        e: 1,
        f: 4,
        g: 2,
        h: 4,
        i: 1,
        j: 8,
        k: 5,
        l: 1,
        m: 3,
        n: 1,
        o: 1,
        p: 3,
        q: 10,
        r: 1,
        s: 1,
        t: 1,
        u: 1,
        v: 4,
        w: 4,
        x: 8,
        y: 4,
        z: 10,
      };

      let targetLetters = [];
      let solutions = [];
      let solutionSet = new Set();
      let acceptedGuesses = [];
      let wrongGuesses = [];
      let totalScore = 0;
      let isBusy = false;
      let hasRevealedSolutions = false;

      let currentThemeId = themeSelect.value;
      let letterCount = Number(letterCountSelect.value);
      let activeWords = [];
      let activeWordSet = new Set();
      let activeMetaByWord = {};
      let meaningCache = {};
      const themeEntriesMemory = {};

      function syncEntryControls() {
        const shouldDisableEntry = isBusy || hasRevealedSolutions;
        wordInput.disabled = shouldDisableEntry;
        updateTileMatchPreview();

        if (shouldDisableEntry) {
          submitBtn.disabled = true;
          return;
        }

        submitBtn.disabled = !hasAllLettersMatchedInInput();
      }

      function hasAllLettersMatchedInInput() {
        if (!targetLetters.length) {
          return false;
        }
        const typedWord = normalizeForMatch(wordInput.value);
        return getMatchedLetterCount(typedWord, targetLetters) === targetLetters.length;
      }

      function updateTileMatchPreview() {
        const typedWord = normalizeForMatch(wordInput.value);
        const matchedCount = getMatchedLetterCount(typedWord, targetLetters);
        const tileEls = tilesEl.querySelectorAll(".tile");
        tileEls.forEach((tileEl, index) => {
          tileEl.classList.toggle("matched", index < matchedCount);
        });
      }

      function showLoader(message) {
        loaderEl.hidden = false;
        appEl.hidden = true;
        loaderMessageEl.textContent = message;
      }

      function hideLoader() {
        loaderEl.hidden = true;
        appEl.hidden = false;
      }

      function getCacheStorageKey(cacheKey) {
        return `${CACHE_PREFIX}${cacheKey}`;
      }

      function readCache(cacheKey) {
        try {
          const raw = localStorage.getItem(getCacheStorageKey(cacheKey));
          if (!raw) {
            return null;
          }

          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== "object") {
            localStorage.removeItem(getCacheStorageKey(cacheKey));
            return null;
          }

          if (typeof parsed.expiresAt !== "number" || Date.now() > parsed.expiresAt) {
            localStorage.removeItem(getCacheStorageKey(cacheKey));
            return null;
          }

          return parsed.data ?? null;
        } catch {
          return null;
        }
      }

      function pruneCache() {
        try {
          const now = Date.now();
          const cacheEntries = [];

          for (let index = 0; index < localStorage.length; index += 1) {
            const key = localStorage.key(index);
            if (!key || !key.startsWith(CACHE_PREFIX)) {
              continue;
            }

            const raw = localStorage.getItem(key);
            if (!raw) {
              continue;
            }

            try {
              const parsed = JSON.parse(raw);
              if (!parsed || typeof parsed !== "object") {
                localStorage.removeItem(key);
                continue;
              }

              if (typeof parsed.expiresAt !== "number" || parsed.expiresAt <= now) {
                localStorage.removeItem(key);
                continue;
              }

              cacheEntries.push({
                key,
                cachedAt:
                  typeof parsed.cachedAt === "number" ? parsed.cachedAt : parsed.expiresAt,
              });
            } catch {
              localStorage.removeItem(key);
            }
          }

          if (cacheEntries.length <= CACHE_MAX_ENTRIES) {
            return;
          }

          cacheEntries.sort((a, b) => a.cachedAt - b.cachedAt);
          const removeCount = cacheEntries.length - CACHE_MAX_ENTRIES;
          for (let i = 0; i < removeCount; i += 1) {
            localStorage.removeItem(cacheEntries[i].key);
          }
        } catch {
          // localStorage unavailable or blocked; skip pruning
        }
      }

      function writeCache(cacheKey, data) {
        try {
          localStorage.setItem(
            getCacheStorageKey(cacheKey),
            JSON.stringify({
              cachedAt: Date.now(),
              expiresAt: Date.now() + CACHE_TTL_MS,
              data,
            })
          );
          pruneCache();
        } catch {
          // localStorage quota/unavailable; continue without persistence
        }
      }

      async function fetchJsonWithCache(cacheKey, url) {
        const cachedData = readCache(cacheKey);
        if (cachedData !== null) {
          return cachedData;
        }

        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Request failed (${response.status})`);
        }

        const data = await response.json();
        writeCache(cacheKey, data);
        return data;
      }

      function normalizeForMatch(value) {
        return (value || "")
          .trim()
          .toLowerCase()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .replace(/[^a-z]/g, "");
      }

      function isAlphaWord(word) {
        return /^[a-z]+$/.test(word);
      }

      function containsInOrder(word, letters) {
        let fromIndex = 0;
        for (const letter of letters) {
          const index = word.indexOf(letter, fromIndex);
          if (index === -1) {
            return false;
          }
          fromIndex = index + 1;
        }
        return true;
      }

      function getMatchedLetterCount(word, letters) {
        if (!word || !letters.length) {
          return 0;
        }

        let fromIndex = 0;
        let count = 0;
        for (const letter of letters) {
          const index = word.indexOf(letter, fromIndex);
          if (index === -1) {
            break;
          }
          count += 1;
          fromIndex = index + 1;
        }
        return count;
      }

      function levenshteinDistance(a, b) {
        if (a === b) {
          return 0;
        }
        if (!a.length) {
          return b.length;
        }
        if (!b.length) {
          return a.length;
        }

        let previousRow = new Array(b.length + 1);
        let currentRow = new Array(b.length + 1);

        for (let j = 0; j <= b.length; j += 1) {
          previousRow[j] = j;
        }

        for (let i = 1; i <= a.length; i += 1) {
          currentRow[0] = i;
          const aCode = a.charCodeAt(i - 1);

          for (let j = 1; j <= b.length; j += 1) {
            const cost = aCode === b.charCodeAt(j - 1) ? 0 : 1;
            currentRow[j] = Math.min(
              previousRow[j] + 1,
              currentRow[j - 1] + 1,
              previousRow[j - 1] + cost
            );
          }

          const swap = previousRow;
          previousRow = currentRow;
          currentRow = swap;
        }

        return previousRow[b.length];
      }

      function fuzzySimilarityPercent(a, b) {
        const maxLength = Math.max(a.length, b.length);
        if (!maxLength) {
          return 100;
        }

        const distance = levenshteinDistance(a, b);
        const similarity = ((maxLength - distance) / maxLength) * 100;
        return Math.max(0, Math.round(similarity));
      }

      function getClosestSolutionPercent(word) {
        if (!word || !solutions.length) {
          return 0;
        }

        let best = 0;
        for (const solutionWord of solutions) {
          const percent = fuzzySimilarityPercent(word, solutionWord);
          if (percent > best) {
            best = percent;
          }
          if (best === 100) {
            break;
          }
        }
        return best;
      }

      function titleCaseFromDashText(value) {
        return (value || "")
          .split("-")
          .filter(Boolean)
          .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
          .join(" ");
      }

      function setStatus(message, type = "neutral") {
        statusEl.textContent = message;
        statusEl.className = "status";
        if (type === "success") {
          statusEl.classList.add("success");
        }
        if (type === "error") {
          statusEl.classList.add("error");
        }
      }

      function setBusyState(value) {
        isBusy = value;
        showSolutionsBtn.disabled = value;
        newGameBtn.disabled = value;
        themeSelect.disabled = value;
        letterCountSelect.disabled = value;
        syncEntryControls();
      }

      function updateRuleText() {
        wordInput.placeholder =
          currentThemeId === "dictionary"
            ? "Type your guess and press Enter"
            : "Type a name and press Enter";
      }

      function updateSolutionsButtonLabel() {
        showSolutionsBtn.textContent = `Show All Solutions (${solutions.length})`;
      }

      function renderTiles() {
        tilesEl.innerHTML = "";
        targetLetters.forEach((letter) => {
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.textContent = letter;
          tilesEl.appendChild(tile);
        });
      }

      function renderScoreboard() {
        scoreEl.textContent = totalScore;
        acceptedCountEl.textContent = acceptedGuesses.length;
        wrongCountEl.textContent = wrongGuesses.length;
      }

      function renderAcceptedWords() {
        acceptedListEl.innerHTML = "";
        if (!acceptedGuesses.length) {
          acceptedListEl.innerHTML = "<li>No accepted words yet.</li>";
          return;
        }

        acceptedGuesses.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = `${item.displayWord} (+${item.points}) - ${item.meaning}`;
          acceptedListEl.appendChild(li);
        });
      }

      function renderWrongWords() {
        wrongListEl.innerHTML = "";
        if (!wrongGuesses.length) {
          wrongListEl.innerHTML = "<li>No wrong words yet.</li>";
          return;
        }

        wrongGuesses.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = `${item.word} - ${item.closestPercent}% matched`;
          wrongListEl.appendChild(li);
        });
      }

      function updateAllLists() {
        renderScoreboard();
        renderAcceptedWords();
        renderWrongWords();
      }

      function calculateWordScore(word) {
        let sum = 0;
        for (const char of word) {
          sum += SCRABBLE_POINTS[char] || 0;
        }
        return sum + word.length;
      }

      function parseDictionaryText(rawText) {
        const unique = new Set();
        const rows = rawText.split(/\r?\n/);

        rows.forEach((line) => {
          const word = normalizeForMatch(line);
          if (word.length < 2 || !isAlphaWord(word)) {
            return;
          }
          unique.add(word);
        });

        return Array.from(unique).sort((a, b) => a.localeCompare(b));
      }

      function downsampleWords(words, limit) {
        if (words.length <= limit) {
          return words;
        }

        const step = words.length / limit;
        const selected = [];
        const selectedSet = new Set();

        for (let i = 0; i < limit; i += 1) {
          const index = Math.min(words.length - 1, Math.floor(i * step));
          const candidate = words[index];
          if (!selectedSet.has(candidate)) {
            selected.push(candidate);
            selectedSet.add(candidate);
          }
        }

        if (selected.length < limit) {
          for (const word of words) {
            if (selectedSet.has(word)) {
              continue;
            }
            selected.push(word);
            selectedSet.add(word);
            if (selected.length >= limit) {
              break;
            }
          }
        }

        return selected;
      }

      function dedupeEntries(entries) {
        const byWord = {};

        entries.forEach((entry) => {
          if (!entry || !entry.word) {
            return;
          }
          const word = entry.word;
          if (!byWord[word]) {
            byWord[word] = {
              word,
              display: entry.display || word,
              meaning: entry.meaning || "",
            };
            return;
          }

          if (!byWord[word].meaning && entry.meaning) {
            byWord[word].meaning = entry.meaning;
          }
        });

        return Object.values(byWord).sort((a, b) => a.word.localeCompare(b.word));
      }

      async function loadDictionaryEntries() {
        const cachedWords = readCache("theme:dictionary:words");
        if (Array.isArray(cachedWords) && cachedWords.length) {
          return cachedWords.map((word) => ({ word, display: word, meaning: "" }));
        }

        const response = await fetch(DICTIONARY_SOURCE_URL);
        if (!response.ok) {
          throw new Error("Dictionary download failed.");
        }

        const rawText = await response.text();
        const parsedWords = parseDictionaryText(rawText);
        const selectedWords = downsampleWords(parsedWords, DICTIONARY_TARGET_SIZE);
        writeCache("theme:dictionary:words", selectedWords);
        return selectedWords.map((word) => ({ word, display: word, meaning: "" }));
      }

      async function loadPokemonEntries() {
        const cachedEntries = readCache("theme:pokemon:entries");
        if (Array.isArray(cachedEntries) && cachedEntries.length) {
          return cachedEntries;
        }

        const data = await fetchJsonWithCache(
          "theme:pokemon:raw",
          "https://pokeapi.co/api/v2/pokemon?limit=2000"
        );

        const entries = dedupeEntries(
          (data.results || [])
            .map((item) => {
              const display = titleCaseFromDashText(item.name || "");
              const word = normalizeForMatch(item.name || "");
              if (word.length < 2) {
                return null;
              }
              return {
                word,
                display,
                meaning: "Pokemon name.",
              };
            })
            .filter(Boolean)
        );

        writeCache("theme:pokemon:entries", entries);
        return entries;
      }

      async function loadGeoEntries(kind) {
        const cacheKey =
          kind === "countries" ? "theme:countries:entries" : "theme:capitals:entries";
        const cachedEntries = readCache(cacheKey);
        if (Array.isArray(cachedEntries) && cachedEntries.length) {
          return cachedEntries;
        }

        const countriesData = await fetchJsonWithCache(
          "theme:geo:raw",
          "https://restcountries.com/v3.1/all?fields=name,capital"
        );

        const countryEntries = [];
        const capitalEntries = [];

        countriesData.forEach((item) => {
          const countryName = (item?.name?.common || "").trim();
          const countryWord = normalizeForMatch(countryName);
          if (countryWord.length >= 2) {
            countryEntries.push({
              word: countryWord,
              display: countryName,
              meaning: "Country name.",
            });
          }

          const capitals = Array.isArray(item?.capital) ? item.capital : [];
          capitals.forEach((capital) => {
            const display = (capital || "").trim();
            const word = normalizeForMatch(display);
            if (word.length < 2) {
              return;
            }
            capitalEntries.push({
              word,
              display,
              meaning: countryName ? `Capital city of ${countryName}.` : "Capital city.",
            });
          });
        });

        const uniqueCountries = dedupeEntries(countryEntries);
        const uniqueCapitals = dedupeEntries(capitalEntries);
        writeCache("theme:countries:entries", uniqueCountries);
        writeCache("theme:capitals:entries", uniqueCapitals);

        return kind === "countries" ? uniqueCountries : uniqueCapitals;
      }

      async function loadEntriesForTheme(themeId) {
        if (themeEntriesMemory[themeId]) {
          return themeEntriesMemory[themeId];
        }

        let entries = [];
        if (themeId === "dictionary") {
          entries = await loadDictionaryEntries();
        } else if (themeId === "pokemon") {
          entries = await loadPokemonEntries();
        } else if (themeId === "countries") {
          entries = await loadGeoEntries("countries");
        } else if (themeId === "capitals") {
          entries = await loadGeoEntries("capitals");
        }

        themeEntriesMemory[themeId] = entries;
        return entries;
      }

      function setActiveEntries(entries) {
        activeWords = [];
        activeMetaByWord = {};

        entries.forEach((entry) => {
          if (!entry || !entry.word || entry.word.length < 2) {
            return;
          }
          activeWords.push(entry.word);
          activeMetaByWord[entry.word] = {
            display: entry.display || entry.word,
            meaning: entry.meaning || "",
          };
        });

        activeWords.sort((a, b) => a.localeCompare(b));
        activeWordSet = new Set(activeWords);
      }

      function getDisplayWord(word) {
        return activeMetaByWord[word]?.display || word;
      }

      function getMeaningCacheKey(word) {
        return `${currentThemeId}:${word}`;
      }

      async function getMeaning(word) {
        const cacheKey = getMeaningCacheKey(word);
        if (meaningCache[cacheKey]) {
          return meaningCache[cacheKey];
        }

        const localMeaning = activeMetaByWord[word]?.meaning;
        if (localMeaning) {
          meaningCache[cacheKey] = localMeaning;
          return localMeaning;
        }

        if (currentThemeId !== "dictionary") {
          meaningCache[cacheKey] = "Meaning unavailable.";
          return meaningCache[cacheKey];
        }

        let meaning = "";
        try {
          const data = await fetchJsonWithCache(
            `dictionaryapi:meaning:${word}`,
            `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(
              word
            )}`
          );
          meaning = data?.[0]?.meanings?.[0]?.definitions?.[0]?.definition || "";
        } catch {
          meaning = "";
        }

        meaningCache[cacheKey] = meaning || "Meaning unavailable.";
        return meaningCache[cacheKey];
      }

      function fetchSolutionsForLetters(letters) {
        const found = [];
        for (const word of activeWords) {
          if (containsInOrder(word, letters)) {
            found.push(word);
          }
        }
        return found;
      }

      function chooseLettersFromWord(word, count) {
        if (count >= word.length) {
          return word.split("").slice(0, count);
        }

        const positions = new Set();
        while (positions.size < count) {
          positions.add(Math.floor(Math.random() * word.length));
        }

        return Array.from(positions)
          .sort((a, b) => a - b)
          .map((index) => word[index]);
      }

      function getMaxSolutionsTarget() {
        if (currentThemeId === "dictionary") {
          if (letterCount === 2) {
            return 900;
          }
          if (letterCount === 3) {
            return 500;
          }
          return 350;
        }
        return 300;
      }

      function isThemeWord(word) {
        return activeWordSet.has(word);
      }

      function rejectGuess(inputWord, dedupeKey, reason) {
        const closestPercent = getClosestSolutionPercent(dedupeKey);
        if (!wrongGuesses.some((item) => item.key === dedupeKey)) {
          wrongGuesses.push({
            key: dedupeKey,
            word: inputWord,
            reason,
            closestPercent,
          });
        }
        renderWrongWords();
        renderScoreboard();
        setStatus(
          `Rejected "${inputWord}": ${reason} Closest solution match: ${closestPercent}%.`,
          "error"
        );
        wordInput.focus();
        wordInput.select();
      }

      async function generateRound() {
        setBusyState(true);
        setStatus("Generating letters and finding solutions...");

        const eligibleWords = activeWords.filter((word) => word.length >= letterCount);
        if (!eligibleWords.length) {
          setBusyState(false);
          setStatus(
            "No words available for this letter count. Try a smaller letter count.",
            "error"
          );
          return;
        }

        const MAX_ATTEMPTS = 420;
        const maxSolutionsTarget = getMaxSolutionsTarget();
        let fallback = null;

        for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt += 1) {
          const seedWord = eligibleWords[Math.floor(Math.random() * eligibleWords.length)];
          const letters = chooseLettersFromWord(seedWord, letterCount);
          const roundSolutions = fetchSolutionsForLetters(letters);

          if (roundSolutions.length < MIN_SOLUTIONS) {
            continue;
          }

          if (!fallback || roundSolutions.length < fallback.solutions.length) {
            fallback = { letters, solutions: roundSolutions };
          }

          if (roundSolutions.length <= maxSolutionsTarget) {
            targetLetters = letters;
            solutions = roundSolutions;
            solutionSet = new Set(roundSolutions);
            updateSolutionsButtonLabel();
            renderTiles();
            setBusyState(false);
            setStatus(
              `New game ready. Letters: ${letters
                .join(" ")
                .toUpperCase()}.`
            );
            wordInput.focus();
            return;
          }
        }

        if (fallback) {
          targetLetters = fallback.letters;
          solutions = fallback.solutions;
          solutionSet = new Set(fallback.solutions);
          updateSolutionsButtonLabel();
          renderTiles();
          setBusyState(false);
          setStatus(
            `New game ready. Letters: ${fallback.letters
              .join(" ")
              .toUpperCase()}.`
          );
          wordInput.focus();
          return;
        }

        setBusyState(false);
        setStatus("Could not generate a round right now. Try New Game.", "error");
      }

      async function startNewGame() {
        currentThemeId = themeSelect.value;
        letterCount = Number(letterCountSelect.value);
        if (!Number.isInteger(letterCount) || letterCount < 2 || letterCount > 6) {
          letterCount = 3;
          letterCountSelect.value = "3";
        }

        targetLetters = [];
        solutions = [];
        solutionSet = new Set();
        acceptedGuesses = [];
        wrongGuesses = [];
        totalScore = 0;
        meaningCache = {};
        hasRevealedSolutions = false;
        wordInput.value = "";

        updateRuleText();
        showSolutionsBtn.hidden = false;
        solutionsBoxEl.textContent = "";
        updateSolutionsButtonLabel();
        updateAllLists();
        renderTiles();
        setBusyState(true);
        setStatus(`Loading ${THEMES[currentThemeId].label}...`);

        try {
          const entries = await loadEntriesForTheme(currentThemeId);
          setActiveEntries(entries);
          await generateRound();
        } catch {
          setBusyState(false);
          setStatus(
            `Error loading ${THEMES[currentThemeId].label}. Please check your internet and try again.`,
            "error"
          );
        }
      }

      async function submitGuess() {
        if (isBusy || !targetLetters.length) {
          return;
        }

        if (!hasAllLettersMatchedInInput()) {
          setStatus(
            `Match all ${targetLetters.length} letters in order before submitting.`,
            "error"
          );
          return;
        }

        const rawInput = wordInput.value.trim();
        const word = normalizeForMatch(rawInput);
        if (!word) {
          return;
        }

        if (!isAlphaWord(word)) {
          rejectGuess(rawInput, word || rawInput.toLowerCase(), "Use letters A-Z only.");
          return;
        }

        if (acceptedGuesses.some((item) => item.word === word)) {
          rejectGuess(rawInput || getDisplayWord(word), word, "You already submitted this word.");
          return;
        }

        if (!containsInOrder(word, targetLetters)) {
          rejectGuess(
            rawInput || getDisplayWord(word),
            word,
            `Word must include ${targetLetters.join("-")} in order.`
          );
          return;
        }

        if (!isThemeWord(word)) {
          rejectGuess(
            rawInput || getDisplayWord(word),
            word,
            `Not found in ${THEMES[currentThemeId].label}.`
          );
          return;
        }

        if (!solutionSet.has(word)) {
          solutionSet.add(word);
          solutions.push(word);
          solutions.sort((a, b) => a.localeCompare(b));
          updateSolutionsButtonLabel();
        }

        const points = calculateWordScore(word);
        const meaning = await getMeaning(word);
        const displayWord = getDisplayWord(word);

        acceptedGuesses.push({ word, displayWord, points, meaning });
        totalScore += points;

        setStatus(`Accepted "${displayWord}" (+${points} points).`, "success");
        wordInput.value = "";
        wordInput.focus();
        syncEntryControls();
        updateAllLists();
      }

      async function showAllSolutions() {
        if (!solutions.length) {
          setStatus("No solutions to show.", "error");
          return;
        }

        hasRevealedSolutions = true;
        syncEntryControls();
        showSolutionsBtn.hidden = true;
        setStatus("Loading meanings for all solutions...");
        setBusyState(true);

        const workers = [];
        const queue = [...solutions];
        const concurrency = currentThemeId === "dictionary" ? 8 : 16;
        const workerCount = Math.min(concurrency, queue.length);

        for (let i = 0; i < workerCount; i += 1) {
          workers.push(
            (async () => {
              while (queue.length) {
                const word = queue.pop();
                await getMeaning(word);
              }
            })()
          );
        }

        await Promise.all(workers);

        solutionsBoxEl.innerHTML = "";
        const list = document.createElement("ul");
        const fragment = document.createDocumentFragment();

        solutions.forEach((word) => {
          const li = document.createElement("li");

          const wordSpan = document.createElement("span");
          wordSpan.className = "solution-word";
          wordSpan.textContent = getDisplayWord(word);

          const meaningSpan = document.createElement("span");
          meaningSpan.className = "solution-meaning";
          meaningSpan.textContent = ` - ${
            meaningCache[getMeaningCacheKey(word)] || "Meaning unavailable."
          }`;

          li.appendChild(wordSpan);
          li.appendChild(meaningSpan);
          fragment.appendChild(li);
        });

        list.appendChild(fragment);
        solutionsBoxEl.appendChild(list);
        setBusyState(false);
        setStatus(`Displayed ${solutions.length} solution(s).`, "success");
      }

      wordInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          if (!submitBtn.disabled) {
            submitGuess();
          }
        }
      });

      wordInput.addEventListener("input", () => {
        syncEntryControls();
      });

      submitBtn.addEventListener("click", submitGuess);
      showSolutionsBtn.addEventListener("click", showAllSolutions);
      newGameBtn.addEventListener("click", startNewGame);
      themeSelect.addEventListener("change", startNewGame);
      letterCountSelect.addEventListener("change", startNewGame);

      async function initializeGame() {
        let initError = "";
        const initialThemeLabel = THEMES[themeSelect.value]?.label || "theme data";
        showLoader(`Loading ${initialThemeLabel}...`);

        try {
          await startNewGame();
        } catch {
          initError = "Error loading game data. Please refresh and try again.";
        } finally {
          hideLoader();
        }

        if (initError) {
          setStatus(initError, "error");
        }
      }

      initializeGame();
    </script>
  </body>
</html>
